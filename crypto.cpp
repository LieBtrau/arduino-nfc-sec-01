#include "crypto.h"


NfcSec01::NfcSec01(bool bIsInitiator):_bIsInitiator(bIsInitiator){}

bool NfcSec01::generateAsymmetricKey(uECC_RNG_Function rng_function)
{
    uECC_set_rng(rng_function);
    const struct uECC_Curve_t * curve = uECC_secp192r1();
    return uECC_make_key(_localPublicKey, _localPrivateKey, curve)!=0;
}

void NfcSec01::generateRandomNFCIDi(uECC_RNG_Function rng_function)
{
    rng_function(_localNFCID3,NFCID_SIZE);
}

void NfcSec01::generateRandomNonce(uECC_RNG_Function rng_function)
{
    rng_function(_localNonce, _96BIT_);
}


byte NfcSec01::getPublicKeySize()
{
    return _192BIT_*2;
}

byte NfcSec01::getPrivateKeySize()
{
    return _192BIT_;
}

byte NfcSec01::getNonceSize(){
    return _96BIT_;
}

bool NfcSec01::setLocalKey(const byte *pLocalPrivateKey, const byte *pLocalPublicKey)
{
    memcpy(_localPrivateKey, pLocalPrivateKey, _192BIT_);
    memcpy(_localPublicKey, pLocalPublicKey, 2*_192BIT_);
    return true;
}

void NfcSec01::setLocalNonce(const byte* localNonce)
{
    memcpy(_localNonce, localNonce, _96BIT_);
}

void NfcSec01::setNFCIDi(const byte* nfcid3i, byte length)
{
    memset(_localNFCID3,0,NFCID_SIZE);
    memcpy(_localNFCID3,nfcid3i,min(NFCID_SIZE,length));
}

void NfcSec01::getLocalNonce(byte* nonce)
{
   memcpy(nonce, _localNonce, _96BIT_);
}

void NfcSec01::getPublicKey(byte* key)
{
    memcpy(key, _localPublicKey, _192BIT_*2);
}

void NfcSec01::getMasterKey(byte* key)
{
    memcpy(key, _MKsse, _128BIT_);
}

void NfcSec01::generateKeyConfirmationTag(const byte* pRemotePublicKey, const byte* pRemoteNFCID3,
                                          byte* KeyConfirmationTag)
{
    byte msg[NFCID_SIZE*2+_192BIT_*4];
    byte cmac[_128BIT_];

    memcpy(msg+(_bIsInitiator?0:NFCID_SIZE), _localNFCID3, NFCID_SIZE);
    memcpy(msg+(_bIsInitiator?NFCID_SIZE:0), pRemoteNFCID3, NFCID_SIZE);
    memcpy(msg+2*NFCID_SIZE+(_bIsInitiator?0:_192BIT_*2), _localPublicKey, _192BIT_*2);
    memcpy(msg+2*NFCID_SIZE+(_bIsInitiator?_192BIT_*2:0), pRemotePublicKey, _192BIT_*2);
    //AES-XCBC-MAC-96 K( ID S || ID R || PK S || PK R)  (MsgID of ECMA-386 was not defined, so it will not be used)
    AES_CMAC(_MKsse, msg, sizeof(msg), cmac);
    memcpy(_KeyConfirmationTag, cmac, _96BIT_);
    memcpy(KeyConfirmationTag, cmac, _96BIT_);
}


bool NfcSec01::checkKeyConfirmation(const byte* pRemoteMacTag)
{
    return(!memcmp(pRemoteMacTag, _KeyConfirmationTag, _96BIT_));
}

//NFC-SEC-1: ECMA-386: Key Agreement + Key Derivation
// A -> B : QA || NA    (QA=public key of A, NA nonce generated by A)
// B <- A : QB || NB    (QA=public key of B, NA nonce generated by B)
bool NfcSec01::calcMasterKeySSE(const byte* pRemotePublicKey, const byte* pRemoteNonce, const byte* pRemoteNFCID3)
{
    const struct uECC_Curve_t * curve = uECC_secp192r1();
    byte SharedSecret[_192BIT_];
    byte S[_128BIT_+2*NFCID_SIZE+1];
    byte SKEYSEED[_128BIT_];

    //Key Agreement
    //  SharedSecret = ECDH(dA,QB);                                                     //shared secret = 192bit
    if(!uECC_shared_secret(pRemotePublicKey, _localPrivateKey, SharedSecret, curve))
    {
        return false;
    }

    //Key Derivation
    //  S = ( NA || NB );                                                               //nonces = (64bit)
    memcpy(S+(_bIsInitiator?0:_128BIT_/2),_localNonce,_128BIT_/2);
    memcpy(S+(_bIsInitiator?_128BIT_/2:0), pRemoteNonce, _128BIT_/2);
    //  SKEYSEED = KDF (S, SharedSecret)                                                //SKEYSEED = 128bit
    AES_CMAC(S, SharedSecret, _128BIT_, SKEYSEED);
    //  MKsse = KDF (SKEYSEED, S || ID S || ID R || (0x01))                             //MKsse = 128bit
    memcpy(S+_128BIT_+(_bIsInitiator?0:NFCID_SIZE),_localNFCID3,NFCID_SIZE);
    memcpy(S+_128BIT_+(_bIsInitiator?NFCID_SIZE:0),pRemoteNFCID3,NFCID_SIZE);
    S[_128BIT_+2*NFCID_SIZE]=0X01;
    AES_CMAC(SKEYSEED, S, sizeof(S), _MKsse);
    return true;
}
