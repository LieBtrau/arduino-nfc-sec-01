#include "crypto.h"

extern "C" { static int RNG(uint8_t *dest, unsigned size);}

NfcSec01::NfcSec01(bool bIsInitiator):_bIsInitiator(bIsInitiator)
{
}

bool NfcSec01::setLocalKey(const byte *pLocalPrivateKey, const byte *pLocalPublicKey)
{
    memcpy(_localPrivateKey, pLocalPrivateKey, _192BIT_);
    memcpy(_localPublicKey, pLocalPublicKey, 2*_192BIT_);
    return true;
}

void NfcSec01::setLocalNonce(const byte* localNonce)
{
    memcpy(_localNonce, localNonce, _96BIT_);
}

void NfcSec01::setNFCIDi(const byte* nfcid3i, byte length)
{
    memset(_localNFCID3,0,NFCID_SIZE);
    memcpy(_localNFCID3,nfcid3i,min(NFCID_SIZE,length));
}

byte* NfcSec01::getLocalNonce(bool bGenerateNew)
{
    if(bGenerateNew)
    {
        RNG(_localNonce, _96BIT_);
    }
    return _localNonce;
}

void NfcSec01::getMasterKey(byte* key)
{
    memcpy(key, _MKsse, _128BIT_);
}

void NfcSec01::generateKeyConfirmationTag(const byte* pRemotePublicKey, const byte* pRemoteNFCID3,
                                          byte* KeyConfirmationTag)
{
    byte msg[NFCID_SIZE*2+_192BIT_*4];
    byte cmac[_128BIT_];

    memcpy(msg+(_bIsInitiator?0:NFCID_SIZE), _localNFCID3, NFCID_SIZE);
    memcpy(msg+(_bIsInitiator?NFCID_SIZE:0), pRemoteNFCID3, NFCID_SIZE);
    memcpy(msg+2*NFCID_SIZE+(_bIsInitiator?0:_192BIT_*2), _localPublicKey, _192BIT_*2);
    memcpy(msg+2*NFCID_SIZE+(_bIsInitiator?_192BIT_*2:0), pRemotePublicKey, _192BIT_*2);
    //AES-XCBC-MAC-96 K( ID S || ID R || PK S || PK R)  (MsgID of ECMA-386 was not defined, so it will not be used)
    AES_CMAC(_MKsse, msg, sizeof(msg), cmac);
    memcpy(_KeyConfirmationTag, cmac, _96BIT_);
    memcpy(KeyConfirmationTag, cmac, _96BIT_);
}


bool NfcSec01::checkKeyConfirmation(const byte* pRemoteMacTag)
{
    return(!memcmp(pRemoteMacTag, _KeyConfirmationTag, _96BIT_));
}

//NFC-SEC-1: ECMA-386: Key Agreement + Key Derivation
// A -> B : QA || NA    (QA=public key of A, NA nonce generated by A)
// B <- A : QB || NB    (QA=public key of B, NA nonce generated by B)
bool NfcSec01::calcMasterKeySSE(const byte* pRemotePublicKey, const byte* pRemoteNonce, const byte* pRemoteNFCID3)
{
    const struct uECC_Curve_t * curve = uECC_secp192r1();
    byte SharedSecret[_192BIT_];
    byte S[_128BIT_+2*NFCID_SIZE+1];
    byte SKEYSEED[_128BIT_];

    //Key Agreement
    //  SharedSecret = ECDH(dA,QB);                                                     //shared secret = 192bit
    if(!uECC_shared_secret(pRemotePublicKey, _localPrivateKey, SharedSecret, curve))
    {
        return false;
    }

    //Key Derivation
    //  S = ( NA || NB );                                                               //nonces = (64bit)
    memcpy(S+(_bIsInitiator?0:_128BIT_/2),_localNonce,_128BIT_/2);
    memcpy(S+(_bIsInitiator?_128BIT_/2:0), pRemoteNonce, _128BIT_/2);
    //  SKEYSEED = KDF (S, SharedSecret)                                                //SKEYSEED = 128bit
    AES_CMAC(S, SharedSecret, _128BIT_, SKEYSEED);
    //  MKsse = KDF (SKEYSEED, S || ID S || ID R || (0x01))                             //MKsse = 128bit
    memcpy(S+_128BIT_+(_bIsInitiator?0:NFCID_SIZE),_localNFCID3,NFCID_SIZE);
    memcpy(S+_128BIT_+(_bIsInitiator?NFCID_SIZE:0),pRemoteNFCID3,NFCID_SIZE);
    S[_128BIT_+2*NFCID_SIZE]=0X01;
    AES_CMAC(SKEYSEED, S, sizeof(S), _MKsse);
    return true;
}

extern "C" {

//TODO: replace by safe external RNG
static int RNG(uint8_t *dest, unsigned size) {
    // Use the least-significant bits from the ADC for an unconnected pin (or connected to a source of
    // random noise). This can take a long time to generate random data if the result of analogRead(0)
    // doesn't change very frequently.
    while (size) {
        uint8_t val = 0;
        for (unsigned i = 0; i < 8; ++i) {
            int init = analogRead(0);
            int count = 0;
            while (analogRead(0) == init) {
                ++count;
            }

            if (count == 0) {
                val = (val << 1) | (init & 0x01);
            } else {
                val = (val << 1) | (count & 0x01);
            }
        }
        *dest = val;
        ++dest;
        --size;
    }
    // NOTE: it would be a good idea to hash the resulting random data using SHA-256 or similar.
    return 1;
}

}  // extern "C"

