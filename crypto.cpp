#include "crypto.h"

extern "C" { static int RNG(uint8_t *dest, unsigned size);}

NfcSec01::NfcSec01()
{
}

bool NfcSec01::setLocalKey(const byte *pLocalPrivateKey, const byte *pLocalPublicKey)
{
    memcpy(_localPrivateKey, pLocalPrivateKey, uECC_BYTES);
    memcpy(_localPublicKey, pLocalPublicKey, uECC_BYTES*2);
    return true;
}

void NfcSec01::setLocalNonce(const byte* localNonce)
{
    memcpy(_localNonce, localNonce, uECC_BYTES);
}

void NfcSec01::setNFCIDi(const byte* nfcid3i, byte length)
{
    memset(_localNFCID3,0,NFCID_SIZE);
    memcpy(_localNFCID3,nfcid3i,min(NFCID_SIZE,length));
}

byte* NfcSec01::getLocalNonce(bool bGenerateNew)
{
    if(bGenerateNew)
    {
        RNG(_localNonce, uECC_BYTES);
    }
    return _localNonce;
}

void NfcSec01::getMasterKey(byte* key)
{
    memcpy(key, _MKsse, BLOCK_SIZE);
}

void NfcSec01::generateKeyConfirmationTag(const byte* pRemotePublicKey, const byte* pRemoteNFCID3,
                                          byte* KeyConfirmationTag, bool bIsInitiator)
{
    byte msg[NFCID_SIZE*2+uECC_BYTES*4];

    memcpy(msg+(bIsInitiator?0:NFCID_SIZE), _localNFCID3, NFCID_SIZE);
    memcpy(msg+(bIsInitiator?NFCID_SIZE:0), pRemoteNFCID3, NFCID_SIZE);
    memcpy(msg+2*NFCID_SIZE+(bIsInitiator?0:uECC_BYTES*2), _localPublicKey, uECC_BYTES*2);
    memcpy(msg+2*NFCID_SIZE+(bIsInitiator?uECC_BYTES*2:0), pRemotePublicKey, uECC_BYTES*2);
    //AES-XCBC-MAC-96 K( ID S || ID R || PK S || PK R)  (MsgID of ECMA-386 was not defined, so it will not be used)
    AES_CMAC(_MKsse, msg, sizeof(msg), KeyConfirmationTag);
}


bool NfcSec01::checkKeyConfirmation(const byte* pRemoteMacTag, const byte* pLocalMacTag)
{
    return(!memcmp(pRemoteMacTag, pLocalMacTag, _96BIT_));
}

//NFC-SEC-1: ECMA-386: Key Agreement + Key Derivation
// A -> B : QA || NA    (QA=public key of A, NA nonce generated by A)
// B <- A : QB || NB    (QA=public key of B, NA nonce generated by B)
bool NfcSec01::calcMasterKeySSE(const byte* pRemotePublicKey, const byte* pRemoteNonce,
                                const byte* pRemoteNFCID3, bool bIsInitiator)
{
    const struct uECC_Curve_t * curve = uECC_secp192r1();
    byte SharedSecret[_192BIT_];
    byte S[BLOCK_SIZE+2*NFCID_SIZE+1];
    byte SKEYSEED[BLOCK_SIZE];

    //Key Agreement
    //  SharedSecret = ECDH(dA,QB);                                                     //shared secret = 192bit
    if(!uECC_shared_secret(pRemotePublicKey, _localPrivateKey, SharedSecret, curve))
    {
        return false;
    }

    //Key Derivation
    //  S = ( NA || NB );                                                               //nonces = (64bit)
    memcpy(S+(bIsInitiator?0:BLOCK_SIZE/2),_localNonce,BLOCK_SIZE/2);
    memcpy(S+(bIsInitiator?BLOCK_SIZE/2:0), pRemoteNonce, BLOCK_SIZE/2);
    //  SKEYSEED = KDF (S, SharedSecret)                                                //SKEYSEED = 128bit
    AES_CMAC(S, SharedSecret, uECC_BYTES, SKEYSEED);
    //  MKsse = KDF (SKEYSEED, S || ID S || ID R || (0x01))                             //MKsse = 128bit
    memcpy(S+BLOCK_SIZE+(bIsInitiator?0:NFCID_SIZE),_localNFCID3,NFCID_SIZE);
    memcpy(S+BLOCK_SIZE+(bIsInitiator?NFCID_SIZE:0),pRemoteNFCID3,NFCID_SIZE);
    S[BLOCK_SIZE+2*NFCID_SIZE]=0X01;
    AES_CMAC(SKEYSEED, S, BLOCK_SIZE+2*NFCID_SIZE+1, _MKsse);
    return true;
}

extern "C" {

//TODO: replace by safe external RNG
static int RNG(uint8_t *dest, unsigned size) {
    // Use the least-significant bits from the ADC for an unconnected pin (or connected to a source of
    // random noise). This can take a long time to generate random data if the result of analogRead(0)
    // doesn't change very frequently.
    while (size) {
        uint8_t val = 0;
        for (unsigned i = 0; i < 8; ++i) {
            int init = analogRead(0);
            int count = 0;
            while (analogRead(0) == init) {
                ++count;
            }

            if (count == 0) {
                val = (val << 1) | (init & 0x01);
            } else {
                val = (val << 1) | (count & 0x01);
            }
        }
        *dest = val;
        ++dest;
        --size;
    }
    // NOTE: it would be a good idea to hash the resulting random data using SHA-256 or similar.
    return 1;
}

}  // extern "C"

